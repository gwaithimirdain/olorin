(* External libraries *)
open Bwd
open Js_of_ocaml

type 'a located = 'a Asai.Range.located

let locate = Asai.Range.locate
let locate_opt = Asai.Range.locate_opt
let locate_map f ({ value; loc } : 'a located) = locate_opt loc (f value)
let carp str = Js_of_ocaml.Console.console##log (Js.string str)

(* Narya libraries *)
open Util
open Dim
open Core
open Term
open Value
open Status
open Parser
open Top
open Reporter

(* Olorin libraries*)
open Firstorder
open Rules
open Objects

(* Directed graphs, indexed separately for traversing forwards and backwards *)

module Source = struct
  type t = Port.t

  let compare = compare
end

module SourceMap = Map.Make (Source)

type fwd_graph = Edge.t list SourceMap.t

module Target = struct
  type t = Port.t

  let compare = compare
end

module TargetMap = Map.Make (Target)

type bwd_graph = Edge.t list TargetMap.t

(* Global variables saved by initialization. *)

let variable_nodes : Vertex.t IdMap.t ref = ref IdMap.empty
let conclusion_node : (Id.t * Vertex.t) option ref = ref None

(* Raw terms with named variables, as an instance of index-parametrized raw terms.  *)

module NameIndices = struct
  type name = { name : string option; port : Port.t option }

  let none : name = { name = None; port = None }

  type 'a index = [ `Name of string | `Port of Port.t ]
  type 'a suc = 'a
  type 'a scope = unit

  (* We allow optional specification of only a limited set of variables that can be used in parsing. *)
  type 'a embed = PortSet.t option * Parser.Notation.wrapped_parse
end

module Named = Raw.Make (NameIndices)

(* We don't need the index 'a, so we set it to unit in most places. *)
type name = NameIndices.name
type index = unit NameIndices.index

(* Since our 'suc' is the identity, this is consistent. *)
let rec namevec_of_vec : type b. (name, b) Vec.t -> (unit, b, unit) Named.Namevec.t =
 fun xs ->
  match xs with
  | [] -> []
  | x :: xs -> x :: namevec_of_vec xs

let parameter_ports = ref PortSet.empty

(* "Unresolving" terms with indices to named terms.  We use this when the user enters textual terms and types in ascriptions and value boxes, in order to include them in the named terms generated by graphs.  *)

module Unresolver = struct
  module I1 = Raw.DeBruijnIndices
  module I2 = NameIndices
  module T1 = Raw.Make (I1)
  module T2 = Raw.Make (I2)

  type ('a1, 'a2) scope = (name, 'a1) Bwv.t

  let matches (x : index) (y : name) =
    match (x, y.name, y.port) with
    | `Name x, Some y, _ -> x = y
    | `Port p, _, Some q -> p = q
    | _ -> false

  let reindex (scope : ('a, 'b) scope) (x : 'a I1.index) =
    match (Bwv.nth x scope).name with
    | Some name -> Ok (`Name name)
    | None -> raise (Jserror "access to unnamed variable")

  let rename _scope (x : I1.name) : name = { name = x; port = None }
  let rescope _scope _ = ()
  let snoc scope x = Bwv.Snoc (scope, ({ name = x; port = None } : name))
  let visit _scope _ = ()

  let embed : ('a1, 'a2) scope -> 'a1 I1.embed -> ('a1 T1.check, 'a2 T2.check) Either.t =
   fun _ -> function
    | _ -> .
end

module Unresolve = Raw.Resolve (Unresolver)

(* When we're resolving the overall term that's connected to the conclusion, we don't want to bail out immediately if we find ill-scoped connections, so that we can potentially continue to resolve and typecheck other parts of the graph.  But when we're resolving a fragment starting from some as-yet-unlabeled output port, we do want to bail out immediately on an ill-scoped connection, because we're trying lots of different scopes and we only want to use the one that works (if there is one).  So we call out from scope_error to a reader effect. *)

module RequireScoping = Algaeff.Reader.Make (Bool)

(* Resolving named terms to ones with indices. *)

module Resolver = struct
  module I1 = NameIndices
  module I2 = Raw.DeBruijnIndices
  module T1 = Raw.Make (I1)
  module T2 = Raw.Make (I2)

  type ('a1, 'a2) scope = (name, 'a2) Bwv.t

  let matches (x : index) (y : name) =
    match (x, y.name, y.port) with
    | `Name x, Some y, _ -> x = y
    | `Port p, _, Some q -> p = q
    | _ -> false

  let reindex scope (x : index) =
    match Bwv.find_opt (matches x) scope with
    | Some (_, y) -> Ok y
    | None ->
        Error
          (if RequireScoping.read () then fatal Code.Ill_scoped_connection
           else Code.Ill_scoped_connection)

  let rename _scope (x : name) = x.name
  let rescope scope () = Bwv.map (fun (x : name) -> x.name) scope
  let snoc scope x = Bwv.Snoc (scope, x)

  (* When we visit any scope while resolving a term that uses named variables into one that uses De-Bruijn indices, we save that scope.  We associated it to the corresponding De Bruijn index term with a hashtable, so that later we can associate it with the appropriate context as well.  The specific hashtable is controlled by an effect.  This way we end up with a collection of all the scopes and contexts that appear anywhere in the graph, so we can try them for synthesizing unconnected output ports. *)

  type wrapped_scope = Scope : 'b Raw.check located * (unit, 'b) scope -> wrapped_scope

  module Scopes = State.Make (struct
    type t = wrapped_scope list
  end)

  (* Possibly this doesn't work in js_of_ocaml? *)
  let () =
    Scopes.register_printer (function
      | `Get -> Some "unhandled Resolver.Scopes get effect"
      | `Set _ -> Some "unhandled Resolver.Scopes set effect")

  let visit scope tm = Scopes.modify (fun scopes -> Scope (tm, scope) :: scopes)

  let embed : ('a1, 'a2) scope -> 'a1 I1.embed -> ('a1 T1.check, 'a2 T2.check) Either.t =
   fun ctx (variables, Notation.Wrap tm) ->
    Reporter.try_with ~fatal:(fun d -> Either.Right (Raw.Indexed.Synth (Fail d.message)))
    @@ fun () ->
    (* If a set of allowed variables was supplied, we un-name all the variables that aren't in it or in the global parameters. *)
    let allowed_ctx =
      match variables with
      | Some variables ->
          Bwv.map
            (fun (x : name) ->
              match x.port with
              | None -> x.name
              | Some p ->
                  if PortSet.mem p variables || PortSet.mem p !parameter_ports then x.name else None)
            ctx
      | None -> Bwv.map (fun (x : name) -> x.name) ctx in
    let tm = Unresolve.check ctx (Postprocess.process allowed_ctx tm) in
    Left tm.value
end

module Scopes = Resolver.Scopes
module Resolve = Raw.Resolve (Resolver)

(* Wrap up the data necessary to resolve a named term and then typecheck it. *)
type context = Context : ('b, 's) status * ('a, 'b) Ctx.t * (unit, 'a) Resolver.scope -> context

(* Some nodes can introduce new names and give a way to re-bind them away.  This is basically doing a one-case match, but not explicitly capturing the subgoal with a bracket in the graph.  Instead, the subgoal extends as far as possible, e.g. to the outermost enclosing explicit bracket (match or abstraction) or to the overall goal. *)

module Bindables = struct
  type binders = {
    (* We save the variables on which this binder depends, so that we can bind only the binders that depend on some local assumptions that are being closed. *)
    used : PortSet.t;
    bind : unit Named.check located -> unit Named.check;
    sbind : unit Named.synth located -> unit Named.synth;
  }

  type t = (name list, binders) Abwd.t

  let empty : t = Abwd.empty
  let fold f bs z = Bwd.fold_right (fun (a, b) x -> f a b x) bs z
  let add (bs : t) (n : name list) (b : binders) : t = Snoc (bs, (n, b))

  let union (xs : t) (ys : t) =
    Bwd.fold_left (fun bs (a, b) -> if Abwd.mem a bs then bs else Snoc (bs, (a, b))) xs ys

  (* Remove all the pairs in 'xs' whose names all appear in 'scope'. *)
  let remove (xs : t) (scope : name list) : t =
    Bwd.filter (fun (n, _) -> not (List.for_all (fun x -> List.mem x scope) n)) xs
end

(* When parsing a graph into a term, we collect all the new names introduced by all of its pieces.  But in case one of those pieces is used in multiple places, we don't want to duplicate that name, so we store them as an abwd indexed by names.  *)

(* A term_with_bindables is a raw term with named variables, together with the new names introduced by its pieces that aren't (yet) in the scope that was given to it.  *)
type term_with_bindables = { bindables : Bindables.t; term : unit Named.check }

let without_bindables term = { bindables = Bindables.empty; term }

(* Given a term_with_bindables, we can perform the bindings for all of its bindables, and obtain an ordinary raw term with named variables.  *)

let bind (tm : term_with_bindables located) : unit Named.check located =
  Bindables.fold
    (fun _ (b : Bindables.binders) x -> locate_opt None (b.bind x))
    tm.value.bindables (locate_opt tm.loc tm.value.term)

let sbind (tm : term_with_bindables located) : unit Named.synth located option =
  match tm.value.term with
  | Synth stm ->
      Some
        (Bindables.fold
           (fun _ (b : Bindables.binders) x -> locate_opt None (b.sbind x))
           tm.value.bindables (locate_opt tm.loc stm))
  | _ -> None

(* We can also bind only those binders that depend on one of a given set of assumptions, and return the rest. *)
let bind_some (vars : PortSet.t) (tm : term_with_bindables located) :
    unit Named.check located * Bindables.t =
  Bindables.fold
    (fun n (b : Bindables.binders) (x, rest) ->
      if PortSet.disjoint vars b.used then (x, Snoc (rest, (n, b)))
      else (locate_opt None (b.bind x), rest))
    tm.value.bindables
    (locate_opt tm.loc tm.value.term, Emp)

(* Ensure that a term_with_bindables is synthesizing, storing an error for later if not *)
let ensure_synth (tm : term_with_bindables located) (err : string) :
    unit Named.synth located * Bindables.t =
  match tm with
  | { value = { bindables; term = Synth tm }; loc } -> (locate_opt loc tm, bindables)
  | { value = { bindables; term = _ }; loc } ->
      (locate_opt loc (Named.Fail (Nonsynthesizing err)), bindables)

(* From graphs to raw terms with named variables *)

(* The fundamental operation takes an output port and produces a raw term with named variables, where as above the "names" might be user-visible strings or hypothesis/assumption ports.  We thread through a set 'seen' that tracks which vertices have been seen, to detect cycles.  We attach Asai "locations" to parts of this term that correspond to *edges* in the graph.  We report as an additional result the set of variable ports on which this term depends.  *)
let rec check_of_output_port ~(seen : IdSet.t) (vertices : Vertex.t IdMap.t) (graph : bwd_graph)
    (source : Port.t) : term_with_bindables located * PortSet.t =
  let oldseen = seen in
  let seen = oldseen |> IdSet.add source.vertex in
  (* We set the current output port as the only location for the term.  Callers can add to that location with Loc.append_to_loc. *)
  let loc = ref (Loc.make [ `Port source ]) in
  (* Assumption ports are technically "cycles" but they are allowed. *)
  if source.sort = Assumption then
    (locate !loc (without_bindables (Synth (Var (`Port source, None)))), PortSet.singleton source)
    (* Other cycles are forbidden. *)
  else if IdSet.mem source.vertex oldseen then
    (locate !loc (without_bindables (Synth (Fail Cyclic_term))), PortSet.empty)
  else
    let source_vertex =
      IdMap.find_opt source.vertex vertices
      <||> "IdMap.find in check_of_graph: missing " ^ Id.to_string source.vertex in
    let tm, variables =
      match source_vertex.rule with
      | Var -> (without_bindables (Synth (Var (`Port source, None))), PortSet.singleton source)
      | Conclusion -> raise (Jserror "conclusion cannot be a source")
      | Tuple { inputs } ->
          let bindables, variables, fields =
            List.fold_left
              (fun (bindables, variables, fields) (assumption, label, fld) ->
                match assumption with
                | None ->
                    let tm, newvars =
                      check_of_input_port ~seen vertices graph
                        { source with sort = Input; label = Some label } in
                    ( Bindables.union bindables tm.value.bindables,
                      PortSet.union variables newvars,
                      Snoc (fields, (Some fld, locate_opt tm.loc tm.value.term)) )
                | Some albl ->
                    let subgoal = { source with sort = Subgoal; label = Some label } in
                    let assumption = { source with sort = Assumption; label = Some albl } in
                    let newbinds, tm, newvars =
                      lam_of_output_port ~seen vertices graph assumption subgoal source_vertex in
                    ( Bindables.union bindables newbinds,
                      PortSet.union variables newvars,
                      Snoc (fields, (Some fld, locate_opt None tm)) ))
              (Bindables.empty, PortSet.empty, Bwd.Emp)
              inputs in
          ({ bindables; term = Named.Struct (Eta, fields) }, variables)
      | Fields { outputs } ->
          let label = source.label <||> "missing label" in
          let fld, _ =
            List.find_opt (fun (_, port) -> port = label) outputs
            <||> "List.find in check_of_graph.Field: missing " ^ label in
          let tm, variables =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = None }
          in
          let tm, bindables = ensure_synth tm "input to field projection" in
          (* We add the location of the projected term to the location of the projections.  This is necessary so that if the input wire has the wrong type, *it* gets highlighted red.  However, we add it as a non-annotating location, so that the input wire doesn't get labeled by an output type. *)
          let newlocs, _ = Loc.locs_and_content false tm.loc in
          loc := Loc.append ~annote:false !loc newlocs;
          ({ bindables; term = Synth (Named.Field (tm, `Name fld)) }, variables)
      | Constr { inputs; constr } ->
          let bindables, variables, args =
            List.fold_right
              (fun label (bindables, variables, args) ->
                let tm, newvars =
                  check_of_input_port ~seen vertices graph
                    { source with sort = Input; label = Some label } in
                ( Bindables.union bindables tm.value.bindables,
                  PortSet.union variables newvars,
                  locate_opt tm.loc tm.value.term :: args ))
              inputs
              (Bindables.empty, PortSet.empty, []) in
          ({ bindables; term = Named.Constr (locate_opt None constr, args) }, variables)
      | App { inputs = fn, arg; field } ->
          let fn, fn_variables =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = Some fn }
          in
          let fn, fn_bindables = ensure_synth fn "function" in
          let ( ({ value = { bindables = arg_bindables; term = argtm }; loc = argloc } :
                  term_with_bindables located),
                arg_variables ) =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = Some arg }
          in
          let arg = locate_opt argloc argtm in
          let term =
            Named.Synth
              (match field with
              | Some fld ->
                  (* We locate the projected function, so that we can locate errors like when the wire connected to the function port isn't a function.  But we don't use those locations for annotations, because we don't want strings to be labeled by types like P→Q instead of P⇒Q. *)
                  Named.App
                    ( locate_opt (Loc.non_annotating fn.loc) (Named.Field (fn, `Name fld)),
                      arg,
                      locate_opt None `Explicit )
              | None -> App (fn, arg, locate_opt None `Explicit)) in
          ( { bindables = Bindables.union fn_bindables arg_bindables; term },
            PortSet.union fn_variables arg_variables )
      | Neg { inputs = fn, arg; field; implicit_pre } ->
          (* Get the two inputs, which we will allow to appear in either order *)
          let get_tm lbl =
            let tm, variables =
              check_of_input_port ~seen vertices graph
                { source with sort = Input; label = Some lbl } in
            let tm, bindables =
              match tm with
              | { value = { bindables; term = Synth tm }; loc } ->
                  (`Synthesizing (locate_opt loc tm), bindables)
              | { value = { bindables; term = tm }; loc } ->
                  (`Nonsynthesizing (locate_opt loc tm), bindables) in
            (tm, bindables, variables) in
          let tm1, bindables1, variables1 = get_tm fn in
          let tm2, bindables2, variables2 = get_tm arg in
          (* Combine the bindables and variables *)
          let bindables = Bindables.union bindables1 bindables2 in
          let variables = PortSet.union variables1 variables2 in
          (* Make an term for applying a (presumed) negation to its un-negated version, including projecting out the field. *)
          let make_direct (fn : 'a located) arg =
            (* We locate the projected function, so that we can locate errors like when the wire connected to the function port isn't a function.  But we don't use those locations for annotations, because we don't want strings to be labeled by types like P→Q instead of P⇒Q. *)
            Named.App
              ( locate_opt (Loc.non_annotating fn.loc) (Named.Field (fn, `Name field)),
                arg,
                locate_opt None `Explicit ) in
          (* Make a term for the same application in the opposite order using a constant, so it can be the unnegated argument that gets synthesized. *)
          let make_reversed fn arg =
            Named.App
              ( locate_opt None
                  (Named.ImplicitSApp
                     ( locate_opt None
                         (Named.Const (Scope.lookup [ implicit_pre ] <||> "implicit_pre not found")),
                       None,
                       fn )),
                arg,
                locate_opt None `Explicit ) in
          let term =
            match (tm1, tm2) with
            (* If one term is synthesizing and the other is not, we try both applying that term as the negation and implicitly using it as the unnegated.  *)
            | `Synthesizing fn, `Nonsynthesizing arg | `Nonsynthesizing arg, `Synthesizing fn ->
                Named.SFirst
                  ( [ (`Any, make_direct fn arg, true); (`Any, make_reversed fn arg, true) ],
                    fn.value )
            (* If both are synthesizing, we try all four possibilities. *)
            | `Synthesizing tm1, `Synthesizing tm2 ->
                SFirst
                  ( [
                      (`Any, make_direct tm1 (locate_map (fun x -> Named.Synth x) tm2), true);
                      (`Any, make_direct tm2 (locate_map (fun x -> Named.Synth x) tm1), true);
                      (`Any, make_reversed tm1 (locate_map (fun x -> Named.Synth x) tm2), true);
                      (`Any, make_reversed tm2 (locate_map (fun x -> Named.Synth x) tm1), true);
                    ],
                    tm1.value )
            (* If neither is synthesizing, we're sunk. *)
            | `Nonsynthesizing fn, `Nonsynthesizing arg ->
                make_direct
                  (locate_opt fn.loc (Named.Fail (Nonsynthesizing "negation argument")))
                  arg in
          (* Finally, we wrap it in a match to make something arbitrary out of ⊥. *)
          let term =
            Named.Synth
              (Named.Match
                 { tm = locate_opt None term; sort = `Implicit; branches = Emp; refutables = None })
          in
          ({ bindables; term }, variables)
      | Abs { field; has_value = _; implicit_post } ->
          (* In an abstraction, we bind all the bindables in the body that involve the assumption variable, and pass the rest on as bindables for the abstraction. *)
          let assumption = { source with sort = Assumption; label = None } in
          let subgoal = { source with sort = Subgoal; label = None } in
          let bindables, lam, variables =
            lam_of_output_port ~seen vertices graph assumption subgoal source_vertex in
          let term =
            match field with
            (* We don't locate the lambda, because we don't want strings to be labeled by *its* type (which would be, say, P→Q instead of P⇒Q). *)
            | Some fld -> Named.Struct (Eta, Snoc (Emp, (Some fld, locate_opt None lam)))
            | None -> lam in
          let term =
            match implicit_post with
            | None -> term
            | Some (fld, fn) ->
                Named.First
                  [
                    (`Codata [ fld ], term, false);
                    ( `Any,
                      Named.ImplicitApp
                        (* Hack by looking up the name in the scope at run-time *)
                        ( locate_opt None
                            (Named.Const
                               (Scope.lookup [ fn ] <||> "implicit_post function not found")),
                          [ (None, locate_opt None term) ] ),
                      false );
                  ] in
          ({ bindables; term }, variables)
      | Match { branches; asc_pre } ->
          let tm, variables =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = None }
          in
          let tm, bindables =
            match asc_pre with
            | None -> ensure_synth tm "match discriminee"
            | Some asc_ty ->
                ( locate_opt tm.loc
                    (Named.Asc
                       ( locate_opt tm.loc tm.value.term,
                         locate_opt None
                           (Named.Synth (Const (Scope.lookup [ asc_ty ] <||> "asc_pre not found")))
                       )),
                  tm.value.bindables ) in
          let branches, bindables, variables =
            List.fold_left
              (fun (brs, bindables, variables) (Branch { assumptions; constr; subgoal }) ->
                let body, newvariables =
                  check_of_input_port ~seen vertices graph
                    { source with sort = Subgoal; label = Some subgoal } in
                let module M = Vec.Monadic (Monad.State (PortSet)) in
                let newvars, assumptions =
                  M.mmapM
                    (fun [ label ] assumptions ->
                      let assumption = { source with sort = Assumption; label = Some label } in
                      ( ({ name = None; port = Some assumption } : name),
                        PortSet.add assumption assumptions ))
                    [ assumptions ] PortSet.empty in
                (* As with an abstraction, we bind all the bindables in the body that involve any of the assumption variables, and pass the rest on as bindables for the abstraction. *)
                let body, newbindables = bind_some assumptions body in
                (* We remove the local assumptions from the variable dependence. *)
                let newvariables = PortSet.diff newvariables assumptions in
                (* We locate each branch at the location of the *match variable*, so that "No_such_constructor_in_match" errors will be associated to the input wire. *)
                let xs = locate_opt (Loc.non_annotating tm.loc) (namevec_of_vec newvars) in
                ( Snoc (brs, (constr, Named.Branch (xs, body))),
                  Bindables.union bindables newbindables,
                  PortSet.union variables newvariables ))
              (Emp, bindables, variables) branches in
          ( {
              bindables;
              term = Synth (Named.Match { tm; sort = `Implicit; branches; refutables = None });
            },
            variables )
      | Coconstr { constr; outputs } ->
          let tm, variables =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = None }
          in
          let tm, bindables = ensure_synth tm "coconstr input" in
          let names =
            List.map
              (fun (named, label) : name ->
                {
                  name = (if named then source_vertex.name else None);
                  port = Some { source with sort = Output; label = Some label };
                })
              outputs in
          let (Wrap vars) = Vec.of_list names in
          let vars = namevec_of_vec vars in
          let bindables =
            Bindables.add bindables names
              {
                used = variables;
                bind =
                  (fun body ->
                    let branch = Named.Branch (locate_opt None vars, body) in
                    let branches = Snoc (Emp, (constr, branch)) in
                    Synth (Named.Match { tm; sort = `Implicit; branches; refutables = None }));
                sbind =
                  (fun body ->
                    let branch =
                      Named.Branch
                        (locate_opt None vars, locate_opt body.loc (Named.Synth body.value)) in
                    let branches = Snoc (Emp, (constr, branch)) in
                    Named.Match { tm; sort = `Implicit; branches; refutables = None });
              } in
          let variables =
            List.fold_right
              (fun (x : name) vars ->
                match x.port with
                | Some p -> PortSet.add p vars
                | None -> vars)
              names variables in
          ({ bindables; term = Synth (Var (`Port source, None)) }, variables)
      | Asc ->
          let tm, variables =
            check_of_input_port ~seen vertices graph { source with sort = Input; label = None }
          in
          let ty = source_vertex.value <||> "missing ascription type" in
          (* TODO: Should locate this on the rule; the output port doesn't get labeled. *)
          let tyloc = Loc.make ~content:ty [ `Port source ] in
          (* We insist that only variables appearing in the inputs can be used. *)
          let ty =
            Reporter.try_with ~fatal:(fun d -> Named.Synth (Fail d.message)) @@ fun () ->
            Named.Embed
              (Some variables, Parse.Term.final (Parse.Term.parse (Asai.Range.source tyloc))) in
          (* We don't currently give the user the option to use variables in the ascription type that don't appear in the input.  If this turns out to be useful, we could supply an extra hasValue input port to Asc that would accept an arbitrary number of wires with variable labels, and then do vars_of_input_port on them and merge the bindables and variables with those of the term, as we do with Expr below. *)
          ( {
              bindables = tm.value.bindables;
              term = Named.Synth (Asc (locate_opt tm.loc tm.value.term, locate tyloc ty));
            },
            variables )
      | Expr ->
          let e = source_vertex.value <||> "missing expression" in
          (* Get all the bindables and variables from all the input wires connected to this rule. *)
          let bindables, variables =
            vars_of_input_port ~seen vertices graph { source with sort = Input; label = None } in
          (* TODO: Should locate this on the rule; the output port doesn't get labeled.  Currently the output *wire* gets a red label when the expression is invalid, which is better than nothing but not optimal. *)
          let eloc = Loc.make ~content:e [ `Port source ] in
          (* Now we insist that only those variables can be used. *)
          let e =
            Reporter.try_with ~fatal:(fun d -> Named.Synth (Fail d.message)) @@ fun () ->
            (* TODO: It would be nice to notice when the expression entered is synthesizing, and label the output port of the expr box in that case. *)
            Named.Embed
              (Some variables, Parse.Term.final (Parse.Term.parse (Asai.Range.source eloc))) in
          ({ bindables; term = e }, variables)
      | Algebra ->
          let nil_eqs = Named.Const (Parser.Scope.lookup [ "nil_eqs" ] <||> "nil_eqs not found") in
          let cons_eqs =
            locate_opt None
              (Named.Const (Parser.Scope.lookup [ "cons_eqs" ] <||> "cons_eqs not found")) in
          let oracle =
            locate_opt None (Named.Const (Parser.Scope.lookup [ "oracle" ] <||> "oracle not found"))
          in
          (* Get all the bindables and variables from all the input wires connected to this rule. *)
          let port = { source with sort = Input; label = None } in
          let givens, bindables, variables =
            List.fold_left
              (fun (givens, bindables, variables) (e : Edge.t) ->
                let tm, new_variables = check_of_output_port ~seen vertices graph e.source in
                (* We have to do these things that check_of_input_port does, since we're not calling it *)
                let tm = Loc.append_to_loc tm [ `Edge e.id; `Port port ] in
                let tm : term_with_bindables located = ascribe_with_user_label tm e in
                let stm =
                  match tm.value.term with
                  | Synth stm -> stm
                  | _ -> Fail (Nonsynthesizing "input to algebra") in
                ( Named.ImplicitSApp
                    ( locate_opt None (Named.ImplicitSApp (cons_eqs, None, locate_opt tm.loc stm)),
                      None,
                      locate_opt None givens ),
                  Bindables.union bindables tm.value.bindables,
                  PortSet.union variables new_variables ))
              (nil_eqs, Bindables.empty, PortSet.empty)
              (Option.value (TargetMap.find_opt port graph) ~default:[]) in
          let term =
            Named.Oracle
              (locate_opt None
                 (Named.ImplicitApp
                    (locate_opt None (Named.ImplicitSApp (oracle, None, locate_opt None givens)), [])))
          in
          ({ bindables; term }, variables)
      | User { const; inputs } ->
          let bindables, variables, args =
            List.fold_left
              (fun (bindables, variables, args) label ->
                let ( ({ value = { term; bindables = tm_bind }; loc } : term_with_bindables located),
                      newvars ) =
                  check_of_input_port ~seen vertices graph
                    { source with sort = Input; label = Some label } in
                ( Bindables.union bindables tm_bind,
                  PortSet.union variables newvars,
                  Snoc (args, locate_opt loc term) ))
              (Bindables.empty, PortSet.empty, Emp)
              inputs in
          let term =
            Bwd.fold_left
              (fun tm arg -> Named.App (locate_opt None tm, arg, locate_opt None `Explicit))
              (Named.Const (Scope.lookup [ const ] <||> "user constant " ^ const ^ " not found"))
              args in
          ({ bindables; term = Named.Synth term }, variables) in
    (locate !loc tm, variables)

(* Subroutine for abstractions and tuples with binding arguments *)
and lam_of_output_port ~seen vertices graph assumption subgoal source_vertex =
  let body, variables = check_of_input_port ~seen vertices graph subgoal in
  let body, bindables = bind_some (PortSet.singleton assumption) body in
  let lam =
    Named.Lam
      ( locate_opt body.loc ({ name = source_vertex.name; port = Some assumption } : name),
        `Normal,
        body ) in
  (* We remove the local assumption from the variable dependence *)
  let variables = PortSet.remove assumption variables in
  (bindables, lam, variables)

and vars_of_input_port ~(seen : IdSet.t) (vertices : Vertex.t IdMap.t) (graph : bwd_graph)
    (port : Port.t) : Bindables.t * PortSet.t =
  let rec go bindables variables edges =
    match edges with
    | [] -> (bindables, variables)
    | (e : Edge.t) :: edges ->
        let ( ({ value = { bindables = new_bindables; term = _ }; loc = _ } :
                term_with_bindables Range.located),
              new_variables ) =
          check_of_output_port ~seen vertices graph e.source in
        go (Bindables.union bindables new_bindables) (PortSet.union variables new_variables) edges
  in
  go Bindables.empty PortSet.empty (Option.value (TargetMap.find_opt port graph) ~default:[])

(* If we're given an input port instead of an output one, we follow the edge attached to it, if any. *)
and check_of_input_port ~(seen : IdSet.t) (vertices : Vertex.t IdMap.t) (graph : bwd_graph)
    (port : Port.t) : term_with_bindables located * PortSet.t =
  match TargetMap.find_opt port graph with
  | Some [ e ] ->
      (* If there is an edge, we get a term from its source port. *)
      let tm, variables = check_of_output_port ~seen vertices graph e.source in
      (* We add that edge and the input port to the location of the resulting term. *)
      let tm = Loc.append_to_loc tm [ `Edge e.id; `Port port ] in
      (* If the edge has a type label, we ascribe it to that label. *)
      let tm = ascribe_with_user_label tm e in
      (tm, variables)
  | Some _ -> raise (Jserror "unexpected multiple edges")
  | None ->
      (* If there isn't an edge, then we return a hole.  We force it to be a leaf of the case tree, so it will be displayed as ? rather than an _UNNAMED_CONSTANT. *)
      let loc = Loc.make [ `Port port ] in
      emit ~loc (No_holes_allowed (`File "graphical proof"));
      ( locate loc
          {
            bindables = Bindables.empty;
            term =
              Realize
                (Hole
                   {
                     scope = ();
                     loc;
                     (* We aren't using these, so we just pick something arbitrary *)
                     li = Interval No.Interval.entire;
                     ri = Interval No.Interval.entire;
                     num = ref 0;
                   });
          },
        PortSet.empty )

and ascribe_with_user_label tm e =
  match e.ty with
  | Some ty ->
      let tyloc = Loc.make ~content:ty [ `Edge e.id ] in
      let ty =
        Reporter.try_with ~fatal:(fun d -> Named.Synth (Fail d.message)) @@ fun () ->
        Named.Embed (None, Parse.Term.final (Parse.Term.parse (Asai.Range.source tyloc))) in
      locate_opt tm.loc
        {
          tm.value with
          term = Named.Synth (Asc (locate_opt tm.loc tm.value.term, locate tyloc ty));
        }
  | None -> tm

(* The first thing we do is start from the conclusion node. *)
let check_of_graph (vertices : Vertex.t IdMap.t) (graph : bwd_graph) :
    term_with_bindables Range.located =
  let vertex = (snd (Option.get !conclusion_node)).id in
  fst
    (check_of_input_port ~seen:(IdSet.singleton vertex) vertices graph
       (* For now, we assume that the conclusion doesn't have a value. *)
       { vertex; sort = Input; label = None })

(* After initialization, we store the context of parameters, variables, and hypotheses, the parsing scope of their names, and the conclusion type in a reference cell wrapped up in a GADT. *)
type problem = Problem : ('a, 'b) Ctx.t * (unit, 'a) Resolver.scope * kinetic value -> problem

let problem : problem option ref = ref None

(* A dummy constant used to pretend to Narya that we're executing a 'def' command. *)
let const : Constant.t option ref = ref None

(* Pause inside effect handlers to return to the browser *)
module Pauser = Pauseable (struct
  type t = js_checked Js.t
end)

(* We've modified Narya to perform 'annotate' effects during typechecking.  Here are our handlers for them. *)

(* Notice the current type, pretty-print it, and add the result to a supplied hashtable of labels by location. *)
let annotate_ty_handler : (Locable.t, Label.t) Hashtbl.t -> printable Asai.Range.located -> unit =
 fun labels { value; loc } ->
  let locs = Loc.annotation_locs loc in
  let buf = Buffer.create 20 in
  PPrint.ToBuffer.pretty 1.0 (Display.columns ()) buf (print value);
  let ty = Buffer.contents buf in
  List.iter (fun loc -> Hashtbl.replace labels loc { ty; tm = None }) locs

(* Notice the current term, pretty-print it, and add it to a supplied hashtable of labels by location, but only if it's on an edge that displays the value of terms (rather than just their types). *)
let annotate_tm_handler (labels : (Locable.t, Label.t) Hashtbl.t)
    ({ value; loc } : printable Asai.Range.located) : unit =
  (* If we get an error printing the term, such as "unimplemented unparsing matches", just bail out and don't annotate anything, but don't consider it a fatal error either. *)
  Reporter.try_with ~fatal:(fun _ -> ()) @@ fun () ->
  let locs = Loc.annotation_locs loc in
  let buf = Buffer.create 20 in
  PPrint.ToBuffer.pretty 1.0 (Display.columns ()) buf (print value);
  let tm = Some (Buffer.contents buf) in
  List.iter
    (fun loc ->
      let lbl = Hashtbl.find labels loc in
      Hashtbl.replace labels loc { lbl with tm })
    locs

(* Notice the current context and status, attach it to the correct scope from a hashtable of scopes by location, and add it to a list of available contexts (to be used for synthesizing disconnected ports). *)
let annotate_ctx_handler : type a b s.
    context list ref -> (b, s) status -> (a, b) Ctx.t -> a Raw.check located -> unit =
 fun contexts status ctx ctxtm ->
  match
    List.find_map
      (fun (Resolver.Scope (scopetm, scope)) ->
        match N.compare (Bwv.length scope) (Ctx.raw_length ctx) with
        | Neq -> None
        | Eq ->
            if scopetm = ctxtm then (
              contexts := Context (status, ctx, scope) :: !contexts;
              Some ())
            else None)
      (Scopes.get ())
  with
  | None ->
      raise
        (Jserror
           (Printf.sprintf "no matching scope for context of length %d"
              (N.to_int (Ctx.raw_length ctx))))
  | Some () -> ()

(* Attempt to parse, resolve, and typecheck a synthesizing term from a given output port by trying all the possible context/scope pairs that we know of so far that it could be in.  Return a flag indicating whether we found a *scope* in which the term *parses*.  If so, we return all the error codes generated by trying to check that term.  If not, we return all the error codes generated by looking for scopes (including holes). *)
let synth_output_port (run : (unit -> unit) -> unit) (vertices : Vertex.t IdMap.t)
    (fwd_graph : fwd_graph) (bwd_graph : bwd_graph) (contexts : context list) (p : Port.t) :
    [ `Found_scope of Diagnostic.js Js.t Dynarray.t | `No_scope of Diagnostic.js Js.t Dynarray.t ] =
  let scoping_diagnostics = Dynarray.create () in
  let hole_diagnostics = Dynarray.create () in
  let tm, _ =
    Reporter.try_with ~emit:(fun d ->
        match d.message with
        | No_holes_allowed _ -> Diagnostic.add hole_diagnostics true d
        | _ -> emit_diagnostic d)
    @@ fun () -> check_of_output_port ~seen:IdSet.empty vertices bwd_graph p in
  (* Now we recurse through the supplied contexts/scopes. *)
  let rec look_for_scope contexts =
    match contexts with
    | [] ->
        (* If there are no remaining available scopes, that means we haven't found any, and so we report all the scoping diagnostics. *)
        `No_scope scoping_diagnostics
    | Context
        (type a b s)
        ((status, ctx, scope) : (b, s) status * (a, b) Ctx.t * (unit, a) Resolver.scope)
      :: contexts -> (
        (* Forbid cyclic scopes for coconstrs: if the scope involves any non-assumption ports from this vertex, skip it.  But we don't do this for variable nodes (those specified as "variables" in the overall level), even though technically we should, since those all go into the overall scope at the beginning and we don't have separate scopes and contexts adding them one by one. *)
        match
          ( IdMap.find_opt p.vertex vertices,
            Bwv.find_opt
              (function
                | ({ port = Some (q : Port.t); _ } : name) ->
                    p.vertex = q.vertex && q.sort != Assumption
                | _ -> false)
              scope )
        with
        | Some { rule; _ }, Some _ when rule != Var ->
            (* If there is a cycle, report it, skip this scope and go on to the next one. *)
            Diagnostic.add scoping_diagnostics true (Reporter.diagnostic Cyclic_term);
            look_for_scope contexts
        | _ ->
            (* Now we remove any of the bindables of the term that already appear in the scope, so they don't get duplicated. *)
            let bindables = Bindables.remove tm.value.bindables (Bwv.to_list scope) in
            let tm = { tm with value = { tm.value with bindables } } in
            (* We create a separate array of diagnostics to accumulate while checking this term, since we only want to record them if the scope succeeds. *)
            let diagnostics = Dynarray.create () in
            let ok =
              (* Check if there are any edges coming *out* of the current port. *)
              match SourceMap.find_opt p fwd_graph with
              | Some es ->
                  (* If so, for each of them, we add it to the label of the current term, ascribe by its user label if any, and proceed, accumulating errors from all cases and requiring them all to succeed. *)
                  List.fold_left
                    (fun ok (e : Edge.t) ->
                      let tm = ascribe_with_user_label (Loc.append_to_loc tm [ `Edge e.id ]) e in
                      ok && synth_term_in_scope status ctx scope tm diagnostics)
                    true es
              | None ->
                  (* Otherwise, we just go ahead. *)
                  synth_term_in_scope status ctx scope tm diagnostics in
            (* If all of those checkings succeeded, we report success and our diagnostics; otherwise we discard those diagnostics and go on to the next scope. *)
            if ok then (
              Dynarray.append diagnostics hole_diagnostics;
              `Found_scope diagnostics)
            else look_for_scope contexts)
  (* Try to synthesize a term in a given scope.  Returns true if the term is well *scoped*, even if it doesn't synthesize.  Record typechecking errors to the supplied diagnostics array. *)
  and synth_term_in_scope : type a b s.
      (b, s) status ->
      (a, b) Ctx.t ->
      (unit, a) Resolver.scope ->
      term_with_bindables located ->
      Diagnostic.js Js.t Dynarray.t ->
      bool =
   fun status ctx scope tm diagnostics ->
    (* We first bind it and check that it's synthesizing. *)
    match sbind tm with
    | Some stm ->
        (* Resolve to a term with De Bruijn indices.  RequireScoping true means that this will throw "ill-scoped connection" errors.  If we get any such error, that means this scope is no good, so we bail out and go on to the next one.  If we get *other* errors, we must have found a good scope and be typechecking, so we report them as the result. *)
        Reporter.try_with ~fatal:(fun d ->
            match d.message with
            | Ill_scoped_connection | Cyclic_term ->
                (* But we do record the scoping diagnostic to the *overall* outside one, to be saved. *)
                Diagnostic.add scoping_diagnostics true d;
                false
            | _ ->
                (* If we get a different fatal error, that means *scope* checking still succeeded, since this is a typechecking error. *)
                Diagnostic.add diagnostics true d;
                true)
        @@ fun () ->
        let (stm, scopes) : a Raw.synth located * Resolver.wrapped_scope list =
          (* We only want to record the new scopes observed in the case that succeeds (if any), so we make a new map in each "go" invocation. *)
          Scopes.run ~init:[] @@ fun () ->
          let stm = RequireScoping.run ~env:true @@ fun () -> Resolve.synth scope stm in
          (stm, Scopes.get ()) in
        (* But if parsing and resolution succeeded, we merge the scopes we found during this parsing run with the ambient ones.  We have to do this before typechecking it, so that they're available for annotate_ctx_handler to attach to. *)
        Scopes.modify (fun oldscopes -> oldscopes @ scopes);
        (* Now typecheck it, discarding the result (the point is only to annotate). *)
        ( run @@ fun () ->
          let _ = Check.synth status ctx stm in
          () );
        (* And we report scoping success, along with any hole diagnostics created. *)
        true
    (* If parsing succeeds but does not produce a synthesizing term, we still report success, since the wires may be connected correctly but we just don't have enough information to typecheck. *)
    | None -> true in
  look_for_scope contexts

(* Attempt to parse and synthesize terms for all the supplied output ports, which should *not* be the sources of any connections (otherwise, they would get included while checking or synthesizing from other ports, and their diagnostics would be incorrectly reported from this function as not knowing about those edges).  If not all of them succeed, try again with those that failed (since new scopes and contexts may have been observed while synthesizing the others).  Repeat until there is no more progress. *)
let rec synth_output_ports (run : (unit -> unit) -> unit) (vertices : Vertex.t IdMap.t)
    (labels : (Locable.t, Label.t) Hashtbl.t) (fwd_graph : fwd_graph) (bwd_graph : bwd_graph)
    (contexts : context list ref) (ports : (Port.t * Diagnostic.js Js.t Dynarray.t) list)
    (diagnostics : Diagnostic.js Js.t Dynarray.t) =
  let progress = ref false in
  let ports =
    List.filter_map
      (* Each port in the "to do" list maintains its own dynamic array of diagnostics coming from the *last time* we tried all the available scopes and contexts on it.  Thus, if we're going through again, we throw away these arrays from last time and create new ones. *)
      (fun (p, _) ->
        (* If this port has already been labeled by checking something else, we don't need to re-do it. *)
        if Hashtbl.mem labels (`Port p) then None
        else
          (* First we try to parse and synthesize a term in all the possible scopes and contexts. *)
          match synth_output_port run vertices fwd_graph bwd_graph !contexts p with
          (* If we found a working scope/context, we remove that port from the list, and remember that we did something useful. *)
          | `Found_scope ds ->
              progress := true;
              Dynarray.append diagnostics ds;
              None
          (* If we failed to find a working scope/context, save that port to try again later, along with the diagnostics it produced this time. *)
          | `No_scope ds -> Some (p, ds))
      ports in
  if !progress then
    synth_output_ports run vertices labels fwd_graph bwd_graph contexts ports diagnostics
  else ports

(* Initialize the proof engine with the parameters, variables, hypotheses, and conclusion.  These are supplied and parsed in ordinary Narya syntax.  Because the Pauser module has to return the same value in all cases, this function returns the same type js_checked as the "check" function, but it doesn't use much of it: just 'complete' and 'error'. *)
let start (parameters : Variable.js Js.t Js.js_array Js.t)
    (variables : Variable.js Js.t Js.js_array Js.t) (hypotheses : Variable.js Js.t Js.js_array Js.t)
    (conclusion : Variable.js Js.t) : js_checked Js.t =
  (* Catch stderr for errors during loading the startup code and the context and conclusion. *)
  let errbuf = Buffer.create 70 in
  let () = Sys_js.set_channel_flusher stderr (fun str -> Buffer.add_string errbuf str) in
  (* We combine the Olorin parameters, variables, and hypotheses into the Narya parameters *)
  let new_vars = ref IdMap.empty in
  let params =
    Array.fold_right
      (fun x xs -> Variable.of_js `Parameter new_vars x :: xs)
      (Js.to_array parameters)
      (Array.fold_right
         (fun x xs -> Variable.of_js `Variable new_vars x :: xs)
         (Js.to_array variables)
         (Array.fold_right
            (fun x xs -> Variable.of_js `Hypothesis new_vars x :: xs)
            (Js.to_array hypotheses) [])) in
  (* The sole non-interactive input is the startup code. *)
  inputs := Snoc (Emp, `String startup);
  (* Display config *)
  number_metas := false;
  parenthesize_arguments := true;
  extra_spaces := false;
  (* Now we enter run_top through the coroutine interface. *)
  try
    (* We don't use ANSI codes here, since we're just displaying errors to the user in ordinary text.  When Asai gets custom markers, we can colorize these errors with HTML. *)
    Pauser.init ~use_ansi:false ~digit_vars:false ~onechar_ops @@ fun () ->
    install_notations ();
    (* We parse and process the parameters into raw terms.  *)
    let hypcount = ref 0 in
    let params =
      List.map
        (fun ({ name; ty; id = Id id; cls; _ } : Variable.t) : Parameter.t ->
          let title =
            match name with
            | Some name -> Some ("type of " ^ name)
            | None ->
                hypcount := !hypcount + 1;
                Some ("type of hypothesis " ^ string_of_int !hypcount) in
          let cls =
            match cls with
            | `Parameter -> `Line "param"
            | `Variable | `Hypothesis -> `Line "" in
          {
            wslparen = [];
            (* We save the ID, and whether it's a parameter, of each such node as "comments" next to its parameter name. *)
            names = [ (name, [ `Line id; cls ]) ];
            wscolon = [];
            ty = Parse.Term.final (Parse.Term.parse (`String { title; content = ty }));
            wsrparen = [];
          })
        params in
    (* Now process_tel can extract these comments into another (forwards) vector and guarantee that they have the correct length.  *)
    let (Processed_tel (rawctx, varscope, idscope)) = Postprocess.process_tel Emp params in
    let scope =
      (* We then turn them back into a (bacwkards) vector of IDs of the same length as the varscope of names, and combine them into a scope of pairs. *)
      Bwv.mmap
        (fun [ x; y ] : name ->
          {
            name = x;
            port =
              (match y with
              | [ `Line id; `Line isparam ] ->
                  let p = ({ vertex = Id.Id id; sort = Output; label = None } : Port.t) in
                  if isparam <> "" then parameter_ports := PortSet.add p !parameter_ports;
                  Some p
              | _ -> raise (Jserror "unexpected comment"));
          })
        [ varscope; Bwv.append (Raw.bplus_of_tel rawctx) Emp idscope ] in
    (* We parse and process the conclusion, in the scope of variables created by parsing the parameters. *)
    let concl_ty = Js.to_string conclusion##.ty in
    let (Wrap obsty) =
      Parse.Term.final
        (Parse.Term.parse (`String { title = Some "type of conclusion"; content = concl_ty })) in
    let rawty = Postprocess.process varscope obsty in
    (* We check the parameters to produce a context. *)
    let Checked_tel (cparams, ctx), _ = Check.check_tel Ctx.empty rawctx in
    (* And then we check the conclusion type. *)
    let ty = Check.check (Kinetic `Nolet) ctx rawty (universe D.zero) in
    let ety = Norm.eval_term (Ctx.env ctx) ty in
    (* We save the context, variable scope, conclusion type, and nodes.  As the user creates their graph, we will check it against these. *)
    problem := Some (Problem (ctx, scope, ety));
    variable_nodes := !new_vars;
    (conclusion_node :=
       let id = Id.Id (Js.to_string conclusion##.id) in
       Some (id, { id; name = None; rule = Conclusion; value = Some concl_ty }));
    let c = Constant.make (Compunit.Current.read ()) in
    const := Some c;
    let pi_cty = Telescope.pis cparams ty in
    Global.add c pi_cty (Axiom `Parametric);
    (* Assuming all that succeeded, we return no errors to JavaScript to indicate success. *)
    object%js
      val mutable complete = Js.bool false
      val mutable error = Js.null
      val mutable labels = Js.array (Array.of_list [])
      val mutable diagnostics = Js.array (Array.of_list [])
    end
  with Top.Exit ->
    (* If executing the startup code or checking the context and conclusion raised an error, we catch that error in the error buffer and return it. *)
    Out_channel.flush stderr;
    object%js
      val mutable complete = Js.bool false
      val mutable error = Js.some (Js.string (Buffer.contents errbuf))
      val mutable labels = Js.array (Array.of_list [])
      val mutable diagnostics = Js.array (Array.of_list [])
    end

(* "Parse" the current graph into one or more terms and typecheck them all. *)
let check (vertices : Vertex.js Js.t Js.js_array Js.t) (edges : Edge.js Js.t Js.js_array Js.t) :
    js_checked Js.t =
  let labels : (Locable.t, Label.t) Hashtbl.t = Hashtbl.create 20 in
  let diagnostics : Diagnostic.js Js.t Dynarray.t = Dynarray.create () in
  try
    (* Get the context and goal that were set by initialization. *)
    let (Problem (ctx, scope, conclusion_ty)) = Option.get !problem in
    let concl_id, concl_node = Option.get !conclusion_node in
    (* Convert the graph to an OCaml representation. *)
    let vertices =
      Array.fold_left
        (fun m v ->
          let v = Vertex.of_js v in
          m |> IdMap.add v.id v)
        (!variable_nodes |> IdMap.add concl_id concl_node)
        (Js.to_array vertices) in
    let _edges, fwd_graph, bwd_graph =
      Array.fold_left
        (fun (idm, fwd, bwd) e ->
          let e = Edge.of_js e in
          ( idm |> IdMap.add e.id e,
            fwd |> SourceMap.add_to_list e.source e,
            bwd |> TargetMap.add_to_list e.target e ))
        (IdMap.empty, SourceMap.empty, TargetMap.empty)
        (Js.to_array edges) in
    (* Accumulate the scopes we've seen and the IDs associated to them *)
    Scopes.run ~init:[] @@ fun () ->
    (* Trap diagnostics and add them to a dynamic array to be passed back to javascript. *)
    Pauser.next @@ fun () ->
    let contexts = ref [] in
    let run f =
      Global.HolesAllowed.run ~env:(Ok ()) @@ fun () ->
      History.do_command @@ fun () ->
      Annotate.run
        ~ctx:{ handle = (fun p -> annotate_ctx_handler contexts p) }
        ~tm:(fun p -> annotate_tm_handler labels p)
        ~ty:(fun p -> annotate_ty_handler labels p)
      @@ fun () -> f () in
    let fatal_error =
      Reporter.try_with
        ~emit:(fun d ->
          match d.message with
          | No_holes_allowed _ -> Diagnostic.add diagnostics true d
          | _ -> Diagnostic.add diagnostics false d)
        ~fatal:(fun d ->
          Diagnostic.add diagnostics true d;
          true)
      @@ fun () ->
      (* Supply the Buchberger oracle.  This has to be inside the Reporter.try_with, since it can raise typechecking errors. *)
      Check.Oracle.run ~ask:Oracle.ask @@ fun () ->
      (* Starting from the conclusion, turn the graph into a raw term with named variables. *)
      let conclusion_ntm = bind (check_of_graph vertices bwd_graph) in
      (* Then resolve it into one with De Bruijn indices. *)
      let conclusion_tm =
        RequireScoping.run ~env:false @@ fun () -> Resolve.check scope conclusion_ntm in
      (* Now typecheck that term.  Unattached input ports are represented in the raw term by holes.  So if those places in the term are checkable, typechecking will "succeed".  Whereas if they are synthesizing it will fail with a "Nonsynthesizing" error, which will be caught by the above "Reporter.try_with".   *)
      ( run @@ fun () ->
        let _ =
          Check.check
            (Potential (Constant (Option.get !const, D.zero), Ctx.apps ctx, Ctx.lam ctx))
            ctx conclusion_tm conclusion_ty in
        () );
      (* Therefore, if checking "succeeded", but produced holes, we consider it a fatal error because the term is not complete. *)
      Eternity.unsolved () > 0 in
    (* Now we collect the list of output and assumption ports, in case any of them yield a synthesizing term. *)
    let ports =
      IdMap.fold
        (fun _ (v : Vertex.t) ps ->
          (* We do have to consider even the ones that have a wire running out of them, because it might be connected to a non-synthesizing term from which we couldn't even get started, whereas this term might itself be synthesizing.  *)
          List.map (fun p -> (p, Dynarray.create ())) (outputs_of_vertex v @ assumptions_of_vertex v)
          @ ps)
        vertices [] in
    (* We go through the list repeatedly until no more progress is made. *)
    let ports =
      synth_output_ports run vertices labels fwd_graph bwd_graph contexts ports diagnostics in
    (* Get rid of any created holes. *)
    History.undo_all ();
    (* Combine all the generated diagnostics. *)
    List.iter (fun (_, ds) -> Dynarray.append diagnostics ds) ports;
    object%js
      val mutable complete = Js.bool (not fatal_error)
      val mutable error = Js.null
      val mutable labels = Label.to_js_array labels

      (* And pass back the diagnostics to Javascript. *)
      val mutable diagnostics = Js.array (Dynarray.to_array diagnostics)
    end
    (* If we caught an error, typechecking fails with that error to the console. *)
  with Jserror msg ->
    object%js
      val mutable complete = Js.bool false
      val mutable error = Js.some (Js.string msg)
      val mutable labels = Label.to_js_array labels

      (* Since the error message is what will be displayed, we don't even pass the diagnostics. *)
      val mutable diagnostics = Js.array (Array.of_list [])
    end

(* We interface with JavaScript by exporting an object called 'Narya' with methods. *)
let _ =
  Js.export "Narya"
    (object%js
       method start (parameters : Variable.js Js.t Js.js_array Js.t)
           (variables : Variable.js Js.t Js.js_array Js.t)
           (hypotheses : Variable.js Js.t Js.js_array Js.t) (conclusion : Variable.js Js.t) =
         start parameters variables hypotheses conclusion

       method check (vertices : Vertex.js Js.t Js.js_array Js.t)
           (edges : Edge.js Js.t Js.js_array Js.t) : js_checked Js.t =
         check vertices edges

       (* Check validity of a new local variable name.  We do this in OCaml rather than JavaScript so that we can actually call the lexer, ensuring it remains as consistent as possible with Narya. *)
       method checkVariable (str : Js.js_string Js.t) =
         (* We have to put it in the Pauser too, since the lexer has to perform some effects. *)
         Pauser.next @@ fun () ->
         let str = Js.to_string str in
         let ok =
           match Parser.Lexer.single str with
           | Some (Ident [ _ ]) -> true
           | _ -> false in
         (* Unlike vanilla Narya, we don't let the user shoot themselves in the foot by starting a variable with a numeral or using a special one-character operator. *)
         let ok = ok && not ('0' <= str.[0] && str.[0] <= '9') in
         (* We have to return *)
         let ok = ok && not (Array.exists (fun (_, x) -> x = Token.Ident [ str ]) onechar_ops) in
         (* And since the Pauser always returns the same type, we have to return a js_checked, so we just put the validity test in the 'complete' field. *)
         object%js
           val mutable complete = Js.bool ok
           val mutable error = Js.null
           val mutable labels = Js.array (Array.of_list [])
           val mutable diagnostics = Js.array (Array.of_list [])
         end

       (* Similarly, check that an expression parses.  (Whether it typechecks, including whether its variables resolve, depends on what wires it connects to and hence is in the scope of.) *)
       method checkParse (str : Js.js_string Js.t) =
         Pauser.next @@ fun () ->
         let str = Js.to_string str in
         let ok =
           Reporter.try_with ~fatal:(fun _ -> false) @@ fun () ->
           let _ = Parse.Term.final (Parse.Term.parse (`String { title = None; content = str })) in
           true in
         object%js
           val mutable complete = Js.bool ok
           val mutable error = Js.null
           val mutable labels = Js.array (Array.of_list [])
           val mutable diagnostics = Js.array (Array.of_list [])
         end
    end)
